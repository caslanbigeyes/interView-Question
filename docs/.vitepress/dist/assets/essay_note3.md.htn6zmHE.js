import{_ as s,c as n,o as a,U as p}from"./chunks/framework.HUmqWwux.js";const g=JSON.parse('{"title":"2/20","description":"","frontmatter":{},"headers":[],"relativePath":"essay/note3.md","filePath":"essay/note3.md","lastUpdated":1740738022000}'),e={name:"essay/note3.md"},l=p(`<h1 id="_2-20" tabindex="-1">2/20 <a class="header-anchor" href="#_2-20" aria-label="Permalink to &quot;2/20&quot;">​</a></h1><h1 id="合并两个有序数组" tabindex="-1">合并两个有序数组 <a class="header-anchor" href="#合并两个有序数组" aria-label="Permalink to &quot;合并两个有序数组&quot;">​</a></h1><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> merge</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            nums1[m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums2[i]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><h1 id="serverless" tabindex="-1">serverless <a class="header-anchor" href="#serverless" aria-label="Permalink to &quot;serverless&quot;">​</a></h1><h1 id="docker" tabindex="-1">docker <a class="header-anchor" href="#docker" aria-label="Permalink to &quot;docker&quot;">​</a></h1><h1 id="区块链到底是什么-它具有什么特点" tabindex="-1">区块链到底是什么？它具有什么特点？ <a class="header-anchor" href="#区块链到底是什么-它具有什么特点" aria-label="Permalink to &quot;区块链到底是什么？它具有什么特点？&quot;">​</a></h1><ol><li>去中心化</li><li>不可篡改</li><li>透明可追溯</li><li>高容错性</li><li>智能合约支持</li></ol><h2 id="学习区块链" tabindex="-1">学习区块链 <a class="header-anchor" href="#学习区块链" aria-label="Permalink to &quot;学习区块链&quot;">​</a></h2><p>岗位职责 1、区块链二层链扩容方案工具前端开发； 2、区块链TON生态应用、mini App前端开发; 3. 关注区块链前端前沿技术发展，定期产出行业报告，进行内部培训。 任职要求</p><ol><li>扎实的计算机基础知识，熟悉常用的数据结构、算法和设计模式，并能在日常研发中灵活使用；</li><li>熟练使用HTML5/CSS3熟练地进行页面开发；</li><li>深入理解Web前端开发技术，包括HTML/CSS/JavaScript等，熟悉TypeScript；</li><li>熟练掌握React/Nextjs/tailwind CSS等技术；</li><li>熟悉区块链技术，熟练使⽤Web3库和API，如Web3.js或Ethers.js等，有实际 Dapp/钱包项目研发经验优先；</li><li>熟悉mini app 开发，TON 生态应用开发优先；</li><li>熟悉浏览器插件开发的优先；</li><li>熟悉智能合约编写优先；</li><li>EVM RPC、密码学相关知识熟悉者优先； 10.具有良好的学习能力，对新技术能深入学习，对业务能快速理解；</li></ol><p>分析 大佬简历</p><p>1、 负责组件库的设计和开发以及使用文档编写，基于 Wagmi 和 Ant Design 开发一套适用于海峡链的 Web3 React 组件库，包括基础组件和为海峡链业务场景设计的组件</p><p>wagmi介绍 react hooks库 为链上交互设计</p><p>2、选择使用 React Native 开发 App 同时涉及到 Andorid 原生开发，深层链接钱包（签名交易等），使用 Ethers.js 与合约交互并参与盲盒等多个合约编写</p><h1 id="制作一个链上钱包交易-defi-借贷界面" tabindex="-1">制作一个链上钱包交易 DEFI 借贷界面 <a class="header-anchor" href="#制作一个链上钱包交易-defi-借贷界面" aria-label="Permalink to &quot;制作一个链上钱包交易 DEFI 借贷界面&quot;">​</a></h1><h2 id="_1-编写前端界面" tabindex="-1">1.编写前端界面 <a class="header-anchor" href="#_1-编写前端界面" aria-label="Permalink to &quot;1.编写前端界面&quot;">​</a></h2><p>地址: <a href="https://zp1v56uxy8rdx5ypatb0ockcb9tr6a-oci3--5173--7f809d15.local-credentialless.webcontainer-api.io/" target="_blank" rel="noreferrer">https://zp1v56uxy8rdx5ypatb0ockcb9tr6a-oci3--5173--7f809d15.local-credentialless.webcontainer-api.io/</a></p><h2 id="_2-与区块链交互" tabindex="-1">2.与区块链交互 <a class="header-anchor" href="#_2-与区块链交互" aria-label="Permalink to &quot;2.与区块链交互&quot;">​</a></h2><ul><li>选择区块链平台：如果是DeFi借贷，常用的是Ethereum（或兼容的链，如Polygon），可以选择使用Solidity编写智能合约。</li><li>Web3集成：使用web3.js或ethers.js来与智能合约进行交互。连接到用户的钱包（如MetaMask）来进行交易。</li><li>安装库：npm install ethers 或 npm install web3</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>核心代码： </span></span>
<span class="line"><span>import { ethers } from &#39;ethers&#39;;</span></span>
<span class="line"><span>const provider = new ethers.JsonRpcProvider(&#39;YOUR_INFURA_URL&#39;);</span></span>
<span class="line"><span>const wallet = new ethers.Wallet(&#39;YOUR_PRIVATE_KEY&#39;, provider);</span></span>
<span class="line"><span>const contract = new ethers.Contract(contractAddress, contractABI, wallet);</span></span></code></pre></div><h2 id="_3-智能合约开发" tabindex="-1">3.智能合约开发 <a class="header-anchor" href="#_3-智能合约开发" aria-label="Permalink to &quot;3.智能合约开发&quot;">​</a></h2><ul><li>借贷智能合约：编写智能合约，处理借款、还款、利息计算等逻辑。使用Solidity编写，并进行部署。 参考代码：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>pragma solidity ^0.8.0;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>contract DeFiLending {</span></span>
<span class="line"><span>    mapping(address =&gt; uint) public balances;</span></span>
<span class="line"><span>    mapping(address =&gt; uint) public debts;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    function deposit() public payable {</span></span>
<span class="line"><span>        balances[msg.sender] += msg.value;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    function borrow(uint amount) public {</span></span>
<span class="line"><span>        require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span></span>
<span class="line"><span>        debts[msg.sender] += amount;</span></span>
<span class="line"><span>        payable(msg.sender).transfer(amount);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    function repay(uint amount) public payable {</span></span>
<span class="line"><span>        require(debts[msg.sender] &gt;= amount, &quot;Repayment exceeds debt&quot;);</span></span>
<span class="line"><span>        debts[msg.sender] -= amount;</span></span>
<span class="line"><span>        // handle repayment logic</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// SPDX-License-Identifier: MIT</span></span>
<span class="line"><span>pragma solidity ^0.8.0;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span></span>
<span class="line"><span>import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span></span>
<span class="line"><span>import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span></span>
<span class="line"><span>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span></span>
<span class="line"><span>import &quot;@openzeppelin/contracts/utils/math/SafeMath.sol&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>contract LendingPool is ReentrancyGuard, Ownable {</span></span>
<span class="line"><span>    using SafeMath for uint256;</span></span>
<span class="line"><span>    using SafeERC20 for IERC20;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 代币地址</span></span>
<span class="line"><span>    IERC20 public lendingToken;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 年化利率（基点）：1% = 100</span></span>
<span class="line"><span>    uint256 public borrowAPR = 500; // 5%</span></span>
<span class="line"><span>    uint256 public supplyAPR = 300; // 3%</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 清算阈值，贷款价值比例（基点）</span></span>
<span class="line"><span>    uint256 public liquidationThreshold = 7500; // 75%</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 清算罚金（基点）</span></span>
<span class="line"><span>    uint256 public liquidationPenalty = 500; // 5%</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 每个用户的存款数量</span></span>
<span class="line"><span>    mapping(address =&gt; uint256) public deposits;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 每个用户的借款数量</span></span>
<span class="line"><span>    mapping(address =&gt; uint256) public borrowings;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 最后一次存款/借款操作的时间戳</span></span>
<span class="line"><span>    mapping(address =&gt; uint256) public lastUpdateTimestamp;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 总存款数量</span></span>
<span class="line"><span>    uint256 public totalDeposits;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 总借款数量</span></span>
<span class="line"><span>    uint256 public totalBorrowings;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 事件</span></span>
<span class="line"><span>    event Deposit(address indexed user, uint256 amount);</span></span>
<span class="line"><span>    event Withdraw(address indexed user, uint256 amount);</span></span>
<span class="line"><span>    event Borrow(address indexed user, uint256 amount);</span></span>
<span class="line"><span>    event Repay(address indexed user, uint256 amount);</span></span>
<span class="line"><span>    event Liquidate(address indexed user, address indexed liquidator, uint256 amount);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    constructor(address _lendingToken) {</span></span>
<span class="line"><span>        lendingToken = IERC20(_lendingToken);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 存款函数</span></span>
<span class="line"><span>    function deposit(uint256 _amount) external nonReentrant {</span></span>
<span class="line"><span>        require(_amount &gt; 0, &quot;Amount must be greater than 0&quot;);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 更新存款利息</span></span>
<span class="line"><span>        updateInterest(msg.sender);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 转入代币</span></span>
<span class="line"><span>        lendingToken.safeTransferFrom(msg.sender, address(this), _amount);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 更新状态</span></span>
<span class="line"><span>        deposits[msg.sender] = deposits[msg.sender].add(_amount);</span></span>
<span class="line"><span>        totalDeposits = totalDeposits.add(_amount);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        emit Deposit(msg.sender, _amount);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 提款函数</span></span>
<span class="line"><span>    function withdraw(uint256 _amount) external nonReentrant {</span></span>
<span class="line"><span>        require(_amount &gt; 0, &quot;Amount must be greater than 0&quot;);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 更新存款利息</span></span>
<span class="line"><span>        updateInterest(msg.sender);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        uint256 availableAmount = getWithdrawableAmount(msg.sender);</span></span>
<span class="line"><span>        require(_amount &lt;= availableAmount, &quot;Insufficient withdrawable amount&quot;);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 更新状态</span></span>
<span class="line"><span>        deposits[msg.sender] = deposits[msg.sender].sub(_amount);</span></span>
<span class="line"><span>        totalDeposits = totalDeposits.sub(_amount);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 转出代币</span></span>
<span class="line"><span>        lendingToken.safeTransfer(msg.sender, _amount);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        emit Withdraw(msg.sender, _amount);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 借款函数</span></span>
<span class="line"><span>    function borrow(uint256 _amount) external nonReentrant {</span></span>
<span class="line"><span>        require(_amount &gt; 0, &quot;Amount must be greater than 0&quot;);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 更新利息</span></span>
<span class="line"><span>        updateInterest(msg.sender);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 检查借款额度</span></span>
<span class="line"><span>        uint256 borrowableAmount = getBorrowableAmount(msg.sender);</span></span>
<span class="line"><span>        require(_amount &lt;= borrowableAmount, &quot;Insufficient borrowable amount&quot;);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 更新状态</span></span>
<span class="line"><span>        borrowings[msg.sender] = borrowings[msg.sender].add(_amount);</span></span>
<span class="line"><span>        totalBorrowings = totalBorrowings.add(_amount);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 转出代币</span></span>
<span class="line"><span>        lendingToken.safeTransfer(msg.sender, _amount);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        emit Borrow(msg.sender, _amount);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 还款函数</span></span>
<span class="line"><span>    function repay(uint256 _amount) external nonReentrant {</span></span>
<span class="line"><span>        require(_amount &gt; 0, &quot;Amount must be greater than 0&quot;);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 更新利息</span></span>
<span class="line"><span>        updateInterest(msg.sender);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        require(borrowings[msg.sender] &gt; 0, &quot;No debt to repay&quot;);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        uint256 repayAmount = _amount;</span></span>
<span class="line"><span>        if (_amount &gt; borrowings[msg.sender]) {</span></span>
<span class="line"><span>            repayAmount = borrowings[msg.sender];</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 转入代币</span></span>
<span class="line"><span>        lendingToken.safeTransferFrom(msg.sender, address(this), repayAmount);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 更新状态</span></span>
<span class="line"><span>        borrowings[msg.sender] = borrowings[msg.sender].sub(repayAmount);</span></span>
<span class="line"><span>        totalBorrowings = totalBorrowings.sub(repayAmount);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        emit Repay(msg.sender, repayAmount);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 清算函数</span></span>
<span class="line"><span>    function liquidate(address _borrower) external nonReentrant {</span></span>
<span class="line"><span>        require(borrowings[_borrower] &gt; 0, &quot;No debt to liquidate&quot;);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 更新利息</span></span>
<span class="line"><span>        updateInterest(_borrower);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 检查是否可以清算</span></span>
<span class="line"><span>        require(canLiquidate(_borrower), &quot;Cannot liquidate this position&quot;);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        uint256 debt = borrowings[_borrower];</span></span>
<span class="line"><span>        uint256 collateral = deposits[_borrower];</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 清算罚金</span></span>
<span class="line"><span>        uint256 penalty = debt.mul(liquidationPenalty).div(10000);</span></span>
<span class="line"><span>        uint256 totalDebt = debt.add(penalty);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 确保不超过抵押品总量</span></span>
<span class="line"><span>        if (totalDebt &gt; collateral) {</span></span>
<span class="line"><span>            totalDebt = collateral;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 转入代币偿还债务</span></span>
<span class="line"><span>        lendingToken.safeTransferFrom(msg.sender, address(this), debt);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 更新状态</span></span>
<span class="line"><span>        borrowings[_borrower] = 0;</span></span>
<span class="line"><span>        totalBorrowings = totalBorrowings.sub(debt);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 计算清算人可获得的抵押品数量</span></span>
<span class="line"><span>        uint256 liquidatorReward = totalDebt;</span></span>
<span class="line"><span>        deposits[_borrower] = deposits[_borrower].sub(liquidatorReward);</span></span>
<span class="line"><span>        totalDeposits = totalDeposits.sub(liquidatorReward);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 转出抵押品给清算人</span></span>
<span class="line"><span>        lendingToken.safeTransfer(msg.sender, liquidatorReward);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        emit Liquidate(_borrower, msg.sender, debt);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 更新利息</span></span>
<span class="line"><span>    function updateInterest(address _user) internal {</span></span>
<span class="line"><span>        if (lastUpdateTimestamp[_user] == 0) {</span></span>
<span class="line"><span>            lastUpdateTimestamp[_user] = block.timestamp;</span></span>
<span class="line"><span>            return;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        uint256 timeElapsed = block.timestamp.sub(lastUpdateTimestamp[_user]);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 如果用户有存款，计算存款利息</span></span>
<span class="line"><span>        if (deposits[_user] &gt; 0) {</span></span>
<span class="line"><span>            uint256 interestEarned = deposits[_user]</span></span>
<span class="line"><span>                .mul(supplyAPR)</span></span>
<span class="line"><span>                .mul(timeElapsed)</span></span>
<span class="line"><span>                .div(365 days)</span></span>
<span class="line"><span>                .div(10000);</span></span>
<span class="line"><span>            </span></span>
<span class="line"><span>            deposits[_user] = deposits[_user].add(interestEarned);</span></span>
<span class="line"><span>            totalDeposits = totalDeposits.add(interestEarned);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        // 如果用户有借款，计算借款利息</span></span>
<span class="line"><span>        if (borrowings[_user] &gt; 0) {</span></span>
<span class="line"><span>            uint256 interestAccrued = borrowings[_user]</span></span>
<span class="line"><span>                .mul(borrowAPR)</span></span>
<span class="line"><span>                .mul(timeElapsed)</span></span>
<span class="line"><span>                .div(365 days)</span></span>
<span class="line"><span>                .div(10000);</span></span>
<span class="line"><span>            </span></span>
<span class="line"><span>            borrowings[_user] = borrowings[_user].add(interestAccrued);</span></span>
<span class="line"><span>            totalBorrowings = totalBorrowings.add(interestAccrued);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        lastUpdateTimestamp[_user] = block.timestamp;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取用户可借款额度</span></span>
<span class="line"><span>    function getBorrowableAmount(address _user) public view returns (uint256) {</span></span>
<span class="line"><span>        if (deposits[_user] == 0) {</span></span>
<span class="line"><span>            return 0;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        uint256 maxBorrowable = deposits[_user].mul(liquidationThreshold).div(10000);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        if (borrowings[_user] &gt;= maxBorrowable) {</span></span>
<span class="line"><span>            return 0;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        return maxBorrowable.sub(borrowings[_user]);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取用户可提款额度</span></span>
<span class="line"><span>    function getWithdrawableAmount(address _user) public view returns (uint256) {</span></span>
<span class="line"><span>        uint256 collateralNeeded = 0;</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        if (borrowings[_user] &gt; 0) {</span></span>
<span class="line"><span>            // 如果有借款，需要保持足够的抵押品</span></span>
<span class="line"><span>            collateralNeeded = borrowings[_user].mul(10000).div(liquidationThreshold);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        if (deposits[_user] &lt;= collateralNeeded) {</span></span>
<span class="line"><span>            return 0;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        return deposits[_user].sub(collateralNeeded);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查用户是否可以被清算</span></span>
<span class="line"><span>    function canLiquidate(address _user) public view returns (bool) {</span></span>
<span class="line"><span>        if (borrowings[_user] == 0) {</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        uint256 collateralNeeded = borrowings[_user].mul(10000).div(liquidationThreshold);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        return deposits[_user] &lt; collateralNeeded;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置借款年化利率（仅管理员）</span></span>
<span class="line"><span>    function setBorrowAPR(uint256 _newBorrowAPR) external onlyOwner {</span></span>
<span class="line"><span>        borrowAPR = _newBorrowAPR;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置存款年化利率（仅管理员）</span></span>
<span class="line"><span>    function setSupplyAPR(uint256 _newSupplyAPR) external onlyOwner {</span></span>
<span class="line"><span>        supplyAPR = _newSupplyAPR;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置清算阈值（仅管理员）</span></span>
<span class="line"><span>    function setLiquidationThreshold(uint256 _newThreshold) external onlyOwner {</span></span>
<span class="line"><span>        require(_newThreshold &lt;= 10000, &quot;Threshold too high&quot;);</span></span>
<span class="line"><span>        liquidationThreshold = _newThreshold;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置清算罚金（仅管理员）</span></span>
<span class="line"><span>    function setLiquidationPenalty(uint256 _newPenalty) external onlyOwner {</span></span>
<span class="line"><span>        require(_newPenalty &lt;= 5000, &quot;Penalty too high&quot;);</span></span>
<span class="line"><span>        liquidationPenalty = _newPenalty;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li>合约部署：使用工具如Hardhat或Truffle来部署智能合约。 npm install --save-dev hardhat：初始化Hardhat项目，编写部署脚本，部署到Ethereum或其他EVM兼容链。</li></ul><h2 id="后端和数据库" tabindex="-1">后端和数据库 <a class="header-anchor" href="#后端和数据库" aria-label="Permalink to &quot;后端和数据库&quot;">​</a></h2><p>Node.js后端：搭建一个简单的Node.js后端，用来处理用户数据、交易历史、贷款审核等。你可以使用Express来快速搭建API。 数据库：使用MongoDB或PostgreSQL来存储用户的历史借贷记录、钱包地址等信息，确保与前端交互时能获取用户数据。</p><h2 id="集成与部署" tabindex="-1">集成与部署 <a class="header-anchor" href="#集成与部署" aria-label="Permalink to &quot;集成与部署&quot;">​</a></h2><p>前端部署：使用Vercel、Netlify等平台将前端部署上线。 智能合约部署：将智能合约部署到主网或测试网上（如Rinkeby、Polygon等），并确保前端通过合约地址和ABI正确调用合约功能。 全栈整合：确保前端与后端的数据交互，智能合约与用户钱包的集成，完成整个DeFi借贷功能的交互流程。</p>`,29),i=[l];function t(r,o,c,d,u,h){return a(),n("div",null,i)}const k=s(e,[["render",t]]);export{g as __pageData,k as default};
